[00:00:00]
>> Why are we doing this? [LAUGH] So you basically, if you're writing all your programs in terms of functions, you have all the math available to you. If you decide to not do that at any given point, you lose all the math, all at once. [LAUGH] So I am not a big.

[00:00:19]
Until I got into functional programming, I didn't care about math. But now that it directly affects my programs and it makes them better, now I do and it's a lot of fun. So don't let that scare you away, it's just helpful to have.that at your fingertips. But that's the biggest reason I would say right off the bat, that you might wanna do this.

[00:00:37]
In terms of just practical everyday stuff, your functions are reliable right, they always return the same output for inputs. They don't have these interesting edge cases that we didn't think about up front. They're portable, they're not,stuck in their environment, except for maybe that closure case. And we'll actually actively combat closures tomorrow.

[00:00:58]
[LAUGH] But today, we're gonna be defining functions as portable as possible. And if you have to put them into closure, they're as portable within that closure. Reusable, yes. You get a lot of reusability out of this stuff, right, because they're not basically again, buried in their environment. They're portable.

[00:01:17]
They're testable, same input to output,they're composable. And then finally, we have these properties, which is the math stuff I was about to talk about. But does anybody have any questions on this? Like, why are we doing this? [LAUGH]
I mean, I'm doing it because Dan Abramov told me to do it, but.

[00:01:36]
[LAUGH]

